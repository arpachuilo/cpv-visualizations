<!DOCTYPE html>
<head>
  <meta charset='utf-8'>
  <script src='https://d3js.org/d3.v4.min.js'></script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.17.1/moment.min.js'></script>
</head>
<style>

body {
  font: 10px sans-serif;
}

.group-tick line {
  stroke: #000;
}

.ribbons {
  fill-opacity: 0.67;
}

.key {
  display: inline-block;
  margin-left: 8px;
  margin-right: 1px;
  width: 1em;
  height: 1em;
}

.key.overviewHist {
  background-color: #000000;
}

.key.detailHist {
  background-color: #FFDD89;
}

.key.graph {
  background-color: #00CBDE;
}

.key.table {
  background-color: #F26223;
}

.key.offices {
  background-color: #629926;
}

</style>

<h3>Legend</h3>
<div class='key overviewHist'></div><span>Overview Histogram</span>
<div class='key detailHist'></div><span>Detail Histogram</span>
<div class='key graph'></div><span>Graph</span>
<div class='key table'></div><span>Table</span>
<div class='key offices'></div><span>Office View</span>

<h3>Pick Dataset</h3>
<select id='dataset' onchange='onDatasetChange()'>
  <option value='CPV-A'>CPV-A</option>
  <option value='CPV-B'>CPV-B</option>
  <option value='CPV-C'>CPV-C</option>
  <option value='CPV-E'>CPV-E</option>
  <option value='CPV-F'>CPV-F</option>
  <option value='CPV-G'>CPV-G</option>
  <option value='CPV-H'>CPV-H</option>
  <option value='CPV-I'>CPV-I</option>
  <option value='CPV-J'>CPV-J</option>
</select>

<svg id='vis' width='480' height='480'></svg>

<!-- <div style='width: 1920px; height: 1080px; background:#000; position: relative;'>
  <img style='position: absolute' src='app.png' width='1920' height='1080' />
  <svg style='position: absolute' id='img' width='1920' height='1080'></svg>
</div> -->

<script>

// NOTE: Time / Data controls - Update to react based app

function onDatasetChange () {
  var value = document.getElementById('dataset').value;
  loadData(value)
}

function flattenData (data) {
  var flat = []

  Object.keys(data[0]).forEach(function (key) {
    if (key !== 'id') {
      data[0][key].forEach(function (d) {
        d.id = key
        d.time = moment(d.date)
        flat.push(d)
      })
    }
  })

  flat.sort(function (a, b) {
    return a.time - b.time
  })

  return flat;
}

function convertDataForAOI (data) {
  var keys = {
    'overviewHist': 0,
    'detailHist': 1,
    'graph': 2,
    'table': 3,
    'offices': 4
  }

  var subKeys = {
    'officesCleared': 'offices',
    'officeMouseEnter': 'offices',
    'officeClicked': 'offices',
    'sliderMoved': 'offices',
    'accessTimeClicked': 'table',
    'histogramBrushStart': 'overviewHist',
    'histogramBrushEnd': 'overviewHist',
    'headerClicked': 'table',
    'rowClicked': 'table',
    'rowMouseOver': 'table',
    'tableToggleSelected': 'table',
    'pageChange': 'table',
    'histogramBarClick': 'detailHist',
    'histogramBarMouseEnter': 'detailHist',
    'graphNodeMouseEnter': 'graph'
  }

  var converted = [
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0]
  ];

  var previousId = ''
  var previousTime = ''
  for (let i = 0; i < data.length; i++) {
    if (data[i].id !== 'mouseEnter') {
      if (previousId === '' || previousTime === '') {
        previousId = data[i].id
        previousTime = data[i].time
      }
      if (previousId !== data[i].id) {
        var fromIndex = +keys[subKeys[previousId]]
        var toIndex = +keys[subKeys[data[i].id]]

        if (fromIndex !== toIndex) {
          timeLapsed = data[i].time - previousTime

          converted[fromIndex][toIndex] += timeLapsed
          previousId = data[i].id
          previousTime = data[i].time
        }
      }
    }
  }
  for (let i = 0; i < converted.length; i++) {
    for (let j = 0; j < converted[i].length; j++) {
      converted[i][j] = converted[i][j] / 1000
    }
  }
  console.table(converted)
  return converted;
}

function drawChart (matrix) {
  var svg = d3.select('#vis'),
      width = +svg.attr('width'),
      height = +svg.attr('height'),
      outerRadius = Math.min(width, height) * 0.5 - 40,
      innerRadius = outerRadius - 30;
  svg.selectAll('*').remove() // Doing this as temp patch job
  var formatValue = d3.formatPrefix(',.0', 1e3);

  var chord = d3.chord()
      .padAngle(0.05)
      .sortSubgroups(d3.descending);

  var arc = d3.arc()
      .innerRadius(innerRadius)
      .outerRadius(outerRadius);

  var ribbon = d3.ribbon()
      .radius(innerRadius);

  var color = d3.scaleOrdinal()
      .domain(d3.range(5))
      .range(['#000000', '#FFDD89', '#00CBDE', '#F26223', '#629926']);

  var g = svg.append('g')
      .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')')
      .datum(chord(matrix));

  var group = g.append('g')
      .attr('class', 'groups')
    .selectAll('g')
    .data(function(chords) { return chords.groups; })
    .enter().append('g');

  group.append('path')
      .style('fill', function(d) { return color(d.index); })
      .style('stroke', function(d) { return d3.rgb(color(d.index)).darker(); })
      .attr('d', arc);

  g.append('g')
      .attr('class', 'ribbons')
    .selectAll('path')
    .data(function(chords) { return chords; })
    .enter().append('path')
      .attr('d', ribbon)
      .style('fill', function(d) { return color(d.target.index); })
      .style('stroke', function(d) { return d3.rgb(color(d.target.index)).darker(); });

  // Returns an array of tick angles and values for a given group and step.
  function groupTicks(d, step) {
    var k = (d.endAngle - d.startAngle) / d.value;
    return d3.range(0, d.value, step).map(function(value) {
      return {value: value, angle: value * k + d.startAngle};
    });
  }
}

function drawPointMap (mouse, eye) {
  var svg = d3.select('#img')
  var eyeG = svg.append('g')
  var mouseG = svg.append('g')

  eyeG.selectAll('circle')
    .data(eye).enter().append('circle')
      .attr('r', 5)
      .attr('fill', 'green')
      .attr('fill-opacity', 0.05)
      .attr('cx', function (d) {
        return d.x === '-nan(ind)' ? -100 : d.x
      })
      .attr('cy', function (d) {
        return d.y === '-nan(ind)' ? -100 : d.y
      });

  mouseG.selectAll('circle')
    .data(mouse).enter().append('circle')
      .attr('r', 5)
      .attr('fill', 'blue')
      .attr('fill-opacity', 0.05)
      .attr('cx', function (d) { return d.x })
      .attr('cy', function (d) { return d.y });
}

function loadData (value) {
  var path = 'data/' + value
  d3.text(path + '.csv', function(text) {
    var eye = d3.csvParse('status,x,y,time\n' + text)
    d3.json(path + '.json', function (mouse) {
      let rawMouse = flattenData(mouse)
      drawChart(convertDataForAOI(rawMouse))
      // drawPointMap(rawMouse, eye)
    })
  })
}

loadData('CPV-A')

</script>
